{"config":{"drafts":true,"body":""},"posts":{"year-one":{"title":"Year One","detail":"My first year as a website","read":3,"tags":"blog","comments":true,"slug":"year-one","status":"draft","date":"20-08-2015","body":"<h2 id=\"the-year-in-review\">The Year in Review</h2>\n<p>So my website lasted a year. It&#39;s dead. Gone. Until now: it&#39;s been reincarnated.</p>\n<p>Jekyll is out. Bloat, Ruby, slow unappealing process. Starting Blocks with blog bolted on is in. With a slight redesign.</p>\n<ul>\n<li>Is Jekyll dead?</li>\n<li>The need to redesign</li>\n<li>Measuring success - comments, tweets, analytics</li>\n<li>Future posts, thought-based.</li>\n</ul>\n"},"sails":{"title":"Sails.js","detail":"Hitting the open sea with Sails.js","read":10,"tags":"sails mongodb node","comments":true,"slug":"sails","status":"published","date":"28-08-2014","body":"<p>One of the strengths of Sails is its ability to interface with a range of databases using a uniform API. In this post I&#39;m going to take a look at integrating with MongoDB - the leading NoSQL database. Hopefully by the end of the post you&#39;ll be set up with a Sails server, Mongo database and the basic structure of an app that you can build upon. Let&#39;s get started.</p>\n<h5 id=\"setup-sails\">Setup Sails</h5>\n<p>We&#39;ll begin by installing Sails and creating a new app:</p>\n<pre><code class=\"lang-bash\">$ sudo <span class=\"hljs-built_in\">npm</span> install -g sails\n$ sails <span class=\"hljs-keyword\">new</span> testProject\n</code></pre>\n<p>You&#39;ll get the skeleton <a href=\"https://github.com/balderdashy/sails-docs/tree/master/anatomy/myApp\">structure</a> of a Sails app, including all the Grunt tasks needed to compile and build your app. I looked into swapping over to Gulp but Grunt is so baked-in to Sails it seemed like a waste of time. All the Grunt tasks are abstracted into their own files within the <code>/tasks</code> folder and its easy enough to add your own.</p>\n<p>Next, install the <a href=\"https://github.com/balderdashy/sails-mongo\">Sails MongoDB adapter</a>:</p>\n<pre><code class=\"lang-bash\">$ npm <span class=\"hljs-keyword\">install</span> sails-mongo\n</code></pre>\n<blockquote>\n<p>In Sails, adapters act as the middleman (or middlelady) between the app and the database.</p>\n</blockquote>\n<p>Adapters are essentially plugins for <a href=\"https://github.com/balderdashy/waterline\">Waterline</a> - this is how Sails can access data from a range of databases using a standard syntax. All of your CRUD functions will be routed through Waterline and <em>adapted</em> to a syntax the database understands.</p>\n<p>Once you&#39;ve installed the Mongo adapter, you&#39;ll need to configure your app to use it. Dive into the <code>/config</code> folder and edit the following files:</p>\n<h6 id=\"-config-connections-js\">/config/connections.js</h6>\n<pre><code class=\"lang-js\">module.exports.connections = <span class=\"hljs-keyword\">{</span>\n\n  <span class=\"hljs-keyword\">mongodb: {</span>\n    adapter: <span class=\"hljs-string\">'sails-mongo'</span>,\n    <span class=\"hljs-keyword\">host</span>: <span class=\"hljs-string\">'localhost'</span>,\n    port: <span class=\"hljs-number\">27017</span>,\n    <span class=\"hljs-keyword\">user</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-literal\">password</span>: <span class=\"hljs-string\">''</span>,\n    database: <span class=\"hljs-string\">'testdb'</span>\n  <span class=\"hljs-keyword\">}</span>\n\n<span class=\"hljs-keyword\">}</span>;\n</code></pre>\n<h6 id=\"-config-models-js\">/config/models.js</h6>\n<pre><code class=\"lang-js\"><span class=\"hljs-module\"><span class=\"hljs-keyword\">module</span>.exports.models = </span>{\n\n  connection: <span class=\"hljs-string\">'mongodb'</span>,\n  migrate: <span class=\"hljs-string\">'alter'</span>\n\n};\n</code></pre>\n<h6 id=\"-config-local-js\">/config/local.js</h6>\n<pre><code class=\"lang-js\">module.exports = <span class=\"hljs-keyword\">{</span>\n\n   port: process.env.<span class=\"hljs-constant\">P</span>ORT || <span class=\"hljs-number\">1337</span>,\n   <span class=\"hljs-literal\">environment</span>: process.env.<span class=\"hljs-constant\">N</span>ODE_ENV || <span class=\"hljs-string\">'development'</span>,\n\n   <span class=\"hljs-keyword\">connections: {</span>\n      <span class=\"hljs-keyword\">mongodb: {</span>\n        <span class=\"hljs-keyword\">user</span>: <span class=\"hljs-string\">''</span>,\n        <span class=\"hljs-literal\">password</span>: <span class=\"hljs-string\">''</span>,\n        database: <span class=\"hljs-string\">'testdb'</span>\n      <span class=\"hljs-keyword\">}</span>\n  <span class=\"hljs-keyword\">}</span>\n\n<span class=\"hljs-keyword\">}</span>;\n</code></pre>\n<h5 id=\"setup-mongodb\">Setup MongoDB</h5>\n<p>If you&#39;ve already got Mongo installed you can skip this part. Otherwise, we&#39;ll install MongoDB using <a href=\"http://brew.sh/\">Homebrew</a>. Note - it may take some time for the install to complete so go get a cup of tea and leave it to run. Further info about installation can be found in the <a href=\"http://docs.mongodb.org/manual/tutorial/install-mongodb-on-os-x/#install-mongodb\">Mongo manual</a>. Don&#39;t forget to create a directory for Mongo to store data in once the installation has completed!</p>\n<pre><code class=\"lang-bash\">$ <span class=\"hljs-keyword\">brew </span>update\n$ <span class=\"hljs-keyword\">brew </span>install mongodb\n$ mkdir -p /<span class=\"hljs-preprocessor\">data</span>/db\n</code></pre>\n<p>MongoDB must be started by running <code>mongod</code> before you start your Sails app. Then, if you run <code>sails lift</code> you can view your app at <a href=\"http://localhost:1337/\">http://localhost:1337/</a>.</p>\n<p>Once your MongoDB server is running, you can manage it using the <code>mongo</code> shell:</p>\n<pre><code class=\"lang-bash\">$ mongo\n&gt; <span class=\"hljs-keyword\">db</span> # current <span class=\"hljs-keyword\">db</span>\n&gt; shows dbs # <span class=\"hljs-keyword\">list</span> available dbs\n&gt; <span class=\"hljs-keyword\">use</span> testdb # switch to specified <span class=\"hljs-keyword\">db</span>, <span class=\"hljs-keyword\">in</span> this case testdb\n&gt; <span class=\"hljs-keyword\">db</span>.dropDatabase() # remove current <span class=\"hljs-keyword\">db</span>\n&gt; show collections # <span class=\"hljs-keyword\">list</span> collections within <span class=\"hljs-keyword\">db</span>\n&gt; <span class=\"hljs-keyword\">db</span>.user.find() # <span class=\"hljs-keyword\">query</span> specified collection, <span class=\"hljs-keyword\">in</span> this case user\n</code></pre>\n<p>See <a href=\"http://docs.mongodb.org/manual/tutorial/getting-started/\">Getting started with MongoDB</a> for more.</p>\n<p>For bonus points you can also add a bit of security to your database by creating a new <a href=\"http://docs.mongodb.org/manual/tutorial/add-user-administrator/\">admin user</a>:</p>\n<pre><code class=\"lang-bash\">&gt; <span class=\"hljs-keyword\">use</span> testdb\n&gt; <span class=\"hljs-keyword\">db</span>.createUser(\n  {\n    user: <span class=\"hljs-string\">\"admin\"</span>,\n    <span class=\"hljs-keyword\">pwd</span>: <span class=\"hljs-string\">\"admin\"</span>,\n    roles:\n    [\n      {\n        role: <span class=\"hljs-string\">\"userAdmin\"</span>,\n        <span class=\"hljs-keyword\">db</span>: <span class=\"hljs-string\">\"testdb\"</span>\n      }\n    ]\n  }\n)\n</code></pre>\n<p>These login credentials can then be added to your <code>config/local.js</code> file.</p>\n<h5 id=\"test-it-out\">Test it out</h5>\n<p>First create a new model and controller by running:</p>\n<pre><code class=\"lang-bash\">$ sails generate api <span class=\"hljs-built_ins\">User</span>\n</code></pre>\n<p>Then add some attributes to your new User model (<code>api/models/User.js</code>):</p>\n<pre><code class=\"lang-js\">module.exports = {\n\n  attributes: {\n\n    username: {\n      <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>:</span> <span class=\"hljs-symbol\">'strin</span>g',\n      required: <span class=\"hljs-literal\">true</span>,\n      unique: <span class=\"hljs-literal\">true</span>\n    },\n\n    password: {\n      <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span>:</span> <span class=\"hljs-symbol\">'strin</span>g',\n      required: <span class=\"hljs-literal\">true</span>\n    }\n  }\n};\n</code></pre>\n<p>You can add a record using the model&#39;s JSON API by going to <a href=\"http://localhost:1337/user/create?username=neo&amp;password=test\">http://localhost:1337/user/create?username=neo&amp;password=test</a>. Then view the model at <a href=\"http://localhost:1337/user\">http://localhost:1337/user</a> and your new user should be there!</p>\n<blockquote>\n<p>The automatic routing of the JSON API is handled by <a href=\"http://sailsjs.org/#/documentation/reference/blueprint-api?q=blueprint-routes\">Sails Blueprints</a> and can be configured in <code>config/blueprints.js</code></p>\n</blockquote>\n<p>I&#39;ve only been working with Sails.js for a few days and have found it pretty straight-forward to get started with. This post should get you on your feet quickly but there&#39;s loads more to explore. I&#39;ve included some resources below. Happy sailing and try not to get seasick!</p>\n<h5 id=\"resources\">Resources</h5>\n<ul>\n<li><a href=\"http://sailsjs.org/#/documentation\">Sails.js docs</a></li>\n<li><a href=\"http://irlnathan.github.io/sailscasts\">sailsCasts</a> - these are awesome for getting a basic app up and running</li>\n<li><a href=\"https://coderwall.com/p/njcr7w\">Automatic reloading</a> with forever</li>\n<li><a href=\"http://www.mongodb.com/presentations/building-web-applications-mongodb-introduction\">Intro to MongoDB</a></li>\n<li><a href=\"http://genghisapp.com/\">Genghis app</a> - GUI for MongoDB admin as an alternative to <code>mongo</code> CLI</li>\n</ul>\n"},"jeet":{"title":"Jeet Whizz","detail":"Feel griddy all over","read":10,"tags":"jeet stylus css","comments":true,"slug":"jeet-whizz","status":"published","date":"04-02-2015","body":"<p>It may sound like a cross between insect repellant and a 90s cream cleaner but Jeet is, in fact, a super-intelligent CSS grid system.</p>\n<p><a href=\"http://jeet.gs/\">Jeet</a> sets your grids free and allows you to build robust structures entirely in your stylesheet, away from your markup.</p>\n<blockquote>\n<p>No more needlessly nesting elements. No more rigid twelve column rules. Enjoy building faster with less code, and more flexibility with Jeet.</p>\n</blockquote>\n<h5 id=\"meet-jeet\">Meet Jeet</h5>\n<p>Jeet describes itself as a &quot;human grid&quot;, which means simple, natural syntax is at its core. The API is actually very light (but powerful), making it quick and easy to get started.</p>\n<pre><code class=\"lang-css\"><span class=\"hljs-tag\">article</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">col</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>/<span class=\"hljs-number\">3</span>)</span></span>\n\n<span class=\"hljs-tag\">aside</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">col</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">3</span>)</span></span>\n</code></pre>\n<p>Have a look at the &quot;Getting Started&quot; and &quot;Basic Usage&quot; video tutorials on <a href=\"http://jeet.gs/\">jeet.gs</a> to get a solid overview of the possibilities.</p>\n<h5 id=\"for-better-\">For better...</h5>\n<p>Jeet is designed for use with CSS preprocessors - specifically SASS and Stylus. This allows it to leverage the power of mixins as standard - meaning no markup pollution (think Bootstrap-style classes: <code>&quot;col-6 desktop-half mobile-full cinema-one-tenth arrgghh&quot;</code>) and concise, readable, modular CSS. A great example of this is the built-in alignment mixin - no more crazy absolute center hacks AND IE9+ support with just one line:</p>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.aligned</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">align</span><span class=\"hljs-params\">()</span></span>\n\n<span class=\"hljs-class\">.vertical</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">align</span><span class=\"hljs-params\">(vertical)</span></span>\n\n<span class=\"hljs-class\">.horizontal</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">align</span><span class=\"hljs-params\">(horizontal)</span></span>\n</code></pre>\n<p>Another nice trick is the <code>edit()</code> mixin. This can be applied to a container element to add a semi-transparent grey background to all child <code>col()</code> and <code>span()</code> elements - helpful when constructing an initial wireframe of your grid (and saves adding garish <code>background-colors</code> to everything). And, thanks to the transparency, you can get a feel for nested grid elements.</p>\n<p>One of Jeet&#39;s best features is its column&#39;s <code>cycle</code> attribute, which makes gallery-style grids effortless:</p>\n<pre><code class=\"lang-css\"><span class=\"hljs-class\">.gallery--desktop</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">column</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">4</span>, cycle: <span class=\"hljs-number\">4</span>)</span></span>\n\n<span class=\"hljs-class\">.gallery--mobile</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">column</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">2</span>, uncycle: <span class=\"hljs-number\">4</span>, cycle: <span class=\"hljs-number\">2</span>)</span></span>\n</code></pre>\n<h5 id=\"for-worse-\">For worse...</h5>\n<p>The project is still relatively raw/young, which could be seen as good and bad. I&#39;d like to see a few more helper mixins (something for variable row heights, for example) but also like Jeet&#39;s basic, focussed nature - it&#39;s a grid system that enables you to build unobtrusive yet powerful grids, rapidly. A few more community tutorials and examples may also help boost the user-base.</p>\n<p>One thing to be aware of is the lack of support for pixel-based gutters - currently, Jeet only supports percentage-based gutters for columns. From a pure responsive development point-of-view this is a good thing but from a pixel-perfect design point-of-view it could be an issue. Just something to bare in mind when selecting Jeet as your grid system - as always, check with your designer :wink:</p>\n<h5 id=\"give-it-a-go\">Give it a go</h5>\n<p>I would suggest just giving Jeet a go - draw out a simple grid and then try to build it. Bundle it with <a href=\"http://gulpjs.com/\">Gulp</a> and <a href=\"https://github.com/jenius/rupture\">Rupture</a> for an awesome CSS workflow:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-tag\">gulp</span><span class=\"hljs-class\">.task</span>(<span class=\"hljs-string\">'style'</span>, function () {\n    <span class=\"hljs-tag\">gulp</span><span class=\"hljs-class\">.src</span>(<span class=\"hljs-string\">'./stylus/main.styl'</span>)\n    <span class=\"hljs-class\">.pipe</span>(<span class=\"hljs-function\">stylus</span>({\n        <span class=\"hljs-attribute\">use</span>: [<span class=\"hljs-function\">rupture</span>(), <span class=\"hljs-function\">jeet</span>()],\n        <span class=\"hljs-attribute\">compress</span>: false\n    }))\n    <span class=\"hljs-class\">.pipe</span>(gulp.<span class=\"hljs-function\">dest</span>(<span class=\"hljs-string\">'css'</span>));\n});\n</code></pre>\n<p>The Stylus installation steps on the Jeet site are a bit strange - they insist the package is installed globally but this isn&#39;t necessary. Instead just install it locally to your project and save the dependency to your <code>package.json</code>:</p>\n<pre><code class=\"lang-bash\">$ npm <span class=\"hljs-operator\"><span class=\"hljs-keyword\">install</span> jeet <span class=\"hljs-comment\">--save</span></span>\n</code></pre>\n<h5 id=\"what-next-\">What next?</h5>\n<p>It seems a major refactored version is <a href=\"https://github.com/mojotech/jeet/issues/372#issuecomment-61809596\">on its way</a> so - watch this space - Jeet is only going to get better! Plus, Jeet&#39;s creator - <a href=\"https://github.com/corysimmons\">corysimmons</a> - appears to be a grid-fiend and has open-sourced two other grid-systems: <a href=\"https://github.com/corysimmons/dragon\">dragon</a> and <a href=\"https://github.com/corysimmons/elf\">elf</a> (which <a href=\"http://corysimmons.github.io/elf/\">looks like</a> it supports consistent gutter widths with any valid CSS measurement).</p>\n<p>I&#39;m off to check both of those out! :boom:</p>\n"},"day-one":{"title":"Day One","detail":"My first day as a website","read":3,"tags":"jekyll","comments":true,"slug":"day-one","status":"published","date":"20-08-2014","body":"<p>As the Internet mourns the loss of my old website, the Internet rejoices in the arrival of my new website.</p>\n<p>I started building my original portfolio site sometime around December 2012 when I became disillusioned with my then job. I finished building it around two months later - when I became irreversibly disillusioned with said job. I took up a new role in May 2013 and have learned an absolute shed-load in the past year. So, I thought it was about time I updated my portfolio to reflect my development. I wanted a fresh, (slightly) maturer look in line with my latest skills but also a nod toward the process of learning. Hence my foray into the world of Blog.</p>\n<blockquote>\n<p>My hope is that by having a platform to write on I will explore more and take the time to cement what I discover.</p>\n</blockquote>\n<p>To further maximise the value of creating a new site, I decided to look into some new tech to try out. Enter Jekyll. I first came across Jekyll via <a href=\"http://daverupert.com/2012/11/brander-newer/\">Dave Rupert</a> and thought it seemed like a good fit for me. I found the initial setup enjoyable and liked the structure that came with a Jekyll site. I also took the time to add a layer of customisation, which was less enjoyable but ultimately sweet when it was finished! This included using <a href=\"http://myth.io/\">Myth</a> for the CSS and a sprinkling of CoffeeScript. I&#39;m also using Gulp and Bundler to run my tasks during development and writing.</p>\n<h5 id=\"behind-the-door-to-the-blog\">Behind the door to the blog</h5>\n<p>I&#39;d like this blog to be an escape from the overwhelming stream of &#39;new&#39; that comes with being a modern frontend developer. A place where the advancement of the web moves at a more natural (some may say slower) pace. You&#39;ll still go hunting for the latest theories, tools and advice but will drop in here every so often to let it all sink in.</p>\n<p>I&#39;ll aim to make my thoughts concise and any tutorials I put up precise. My first attempt at this will be via my &quot;hello-world-series&quot; where I&#39;ll share my experiences (and a few code snippets) of using tools like Yeoman, Slush and Polymer for the first time.</p>\n<p>Finally, I don&#39;t claim to be the Oracle on anything and would advise you to tread your own path. Here you shall find the the unofficial word.</p>\n<p>Take it easy! :relaxed:</p>\n"},"angular-sails":{"title":"Angular-Sails","detail":"Plain sailing with Angular","read":10,"tags":"sails angular node","comments":true,"slug":"angular-sails","status":"published","date":"02-12-2014","body":"<p>Get the wind back in your Sails app with an Angular frontend!</p>\n<p>Sure, with Sails you can get a pretty mean API up and running in no time at all and also serve up client-side views in <a href=\"http://sailsjs.org/#/documentation/concepts/Views/ViewEngines.html\">numerous templating languages</a> but <a href=\"https://divshot.com/blog/opinion/every-web-app-is-two-apps/\">as Michael Bleigh put it</a> there are two sides to every web app.</p>\n<p>And to make it nice and simple, Sails is front-end agnostic by design!</p>\n<blockquote>\n<p>Sails is designed to be compatible with any front-end strategy; whether it&#39;s Angular, Backbone, iOS/ObjC, Android/Java, Windows Phone, or something else entirely.</p>\n</blockquote>\n<p>Angular seems to fit particularly nicely when it comes to web apps and there is also an official <a href=\"http://balderdashy.github.io/angularSails/#/api/ngsails.$sailsSocket\">angularSails</a> binding to wrap <a href=\"http://sailsjs.org/#/documentation/reference/websockets/sails.io.js\">Sails&#39; socket.io client</a> - so let&#39;s go with that and see what happens! We&#39;ll aim to have a simple app that&#39;ll display a list of users.</p>\n<h5 id=\"sails\">Sails</h5>\n<p>If you haven&#39;t already got a basic Sails app up and running, its easy - run the following commands and you&#39;ll be good to go:</p>\n<pre><code class=\"lang-bash\"><span class=\"hljs-variable\">$ </span>npm install -g sails\n<span class=\"hljs-variable\">$ </span>sails new angular-sails\n<span class=\"hljs-variable\">$ </span>cd angular-sails\n<span class=\"hljs-variable\">$ </span>sails generate api <span class=\"hljs-constant\">User</span>\n<span class=\"hljs-variable\">$ </span>sails lift\n</code></pre>\n<p>Check that your User API (controller/model) exists by going to the endpoint <a href=\"http://localhost:1337/user\">http://localhost:1337/user</a>. You can add a new user at <a href=\"http://localhost:1337/user/create?username=super&amp;password=heroic\">http://localhost:1337/user/create?username=super&amp;password=heroic</a></p>\n<h5 id=\"-angular\">+ Angular</h5>\n<p>We&#39;ll start by clearing out some of the default Sails stuff and Angular-ising it. Your <code>views/layout.ejs</code> file will need to have the a couple of directives to bootstrap the app and a main controller, so go ahead and modify it with the following:</p>\n<pre><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span> <span class=\"hljs-attribute\">ng-app</span>=<span class=\"hljs-value\">\"app\"</span>&gt;</span>\n...\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">ng-controller</span>=<span class=\"hljs-value\">\"AppController\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">%-</span> <span class=\"hljs-attribute\">body</span> %&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span>\n</code></pre>\n<p>Then, the <code>views/homepage.ejs</code> file will simply contain:</p>\n<pre><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;div ng-view&gt;</span><span class=\"hljs-tag\">&lt;/div&gt;</span>\n</code></pre>\n<p>The homepage view will be injected where the <a href=\"http://sailsjs.org/#/documentation/concepts/Views/Locals.html\">raw HTML local</a> <code>body</code> is placed in the DOM. As this will be a <em>single-page app</em>, the homepage will be the only view used. Make sure your <code>config/routes.js</code> file looks like this:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-module\"><span class=\"hljs-keyword\">module</span>.exports.routes = </span>{\n  <span class=\"hljs-string\">'/'</span>: {\n    view: <span class=\"hljs-string\">'homepage'</span>\n  }\n}\n</code></pre>\n<p>We&#39;ll use <a href=\"http://bower.io/\">Bower</a> to install and manage our Angular dependencies - run <code>bower init</code> in the app root directory to create a <code>bower.json</code> file and then create a <code>.bowerrc</code> file with the following contents:</p>\n<pre><code class=\"lang-js\">{\n  \"<span class=\"hljs-attribute\">directory</span>\": <span class=\"hljs-value\"><span class=\"hljs-string\">\"assets/bower_components\"</span>\n</span>}\n</code></pre>\n<p>This ensures any Bower dependencies are installed in the <code>/assets</code> directory, which is where Sails serves up our static front-end from. Go ahead and install your dependencies:</p>\n<pre><code class=\"lang-bash\">$ bower install --<span class=\"hljs-built_in\">save</span>-<span class=\"hljs-built_in\">dev</span> angular angular-loader angular-mocks angular-route angularSails\n</code></pre>\n<h5 id=\"-a-sprinkle-of-structure\">+ a sprinkle of Structure</h5>\n<p>The best way to start developing a new app is to get a good structure in place - this allows you to visualise the app and be clear on how its different modules will work together. If you&#39;re working with a framework for the first time it&#39;s a good idea to do a bit of reading first or even use a generator. Sails comes with a pretty rigid/opinionated <a href=\"http://sailsjs.org/#/documentation/anatomy/myApp\">base structure</a> whereas Angular leaves it up to you. There are <a href=\"http://scotch.io/tutorials/javascript/angularjs-best-practices-directory-structure\">various approaches</a> and much depends on the projected size of your app. As we&#39;re only setting up a test app, we&#39;ll go with <a href=\"http://briantford.com/blog/huuuuuge-angular-apps\">Brian Ford&#39;s approach</a> slightly modified to fit with Sails:</p>\n<pre><code class=\"lang-no-highlight\">assets\n├── fonts\n├── images\n├── js\n|<span class=\"hljs-string\">   ├── controllers\n</span>|<span class=\"hljs-string\">   </span>|<span class=\"hljs-string\">   └── AppController.js\n</span>|<span class=\"hljs-string\">   </span>|<span class=\"hljs-string\">   └── controllers.js\n</span>|<span class=\"hljs-string\">   </span>|<span class=\"hljs-string\">   └── UserController.js\n</span>|<span class=\"hljs-string\">   ├── dependencies\n</span>|<span class=\"hljs-string\">   </span>|<span class=\"hljs-string\">   └── sails.io.js\n</span>|<span class=\"hljs-string\">   ├── services\n</span>|<span class=\"hljs-string\">   </span>|<span class=\"hljs-string\">   └── services.js\n</span>|<span class=\"hljs-string\">   </span>|<span class=\"hljs-string\">   └── user.js\n</span>|<span class=\"hljs-string\">   └── app.js\n</span>|<span class=\"hljs-string\">   └── directives.js\n</span>|<span class=\"hljs-string\">   └── filters.js\n├── partials\n</span>|<span class=\"hljs-string\">   └── partial.html\n</span>|<span class=\"hljs-string\">   └── ...\n├── styles\n</span>|<span class=\"hljs-string\">   └── main.css\n</span>|<span class=\"hljs-string\">   └── ...\n├── templates\n</span>|<span class=\"hljs-string\">   └── users.html\n</span>|<span class=\"hljs-string\">   └── ...\n├── favicon.ico\n├── robots.txt</span>\n</code></pre>\n<p>Let&#39;s take a closer look at some of those folders and files. First, we&#39;ll get our <code>app.js</code> setup - this is where the app and its dependencies are declared and where our <a href=\"https://docs.angularjs.org/guide/providers\">providers</a> can be configured.</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-pi\">'use strict'</span>;\n\n<span class=\"hljs-comment\">// declare app level module and [dependencies]</span>\nangular.module(<span class=\"hljs-string\">'app'</span>, [\n  <span class=\"hljs-string\">'ngRoute'</span>,\n  <span class=\"hljs-string\">'sails.io'</span>,\n  <span class=\"hljs-string\">'app.controllers'</span>,\n  <span class=\"hljs-string\">'app.services'</span>\n]).\n\n<span class=\"hljs-comment\">// config providers</span>\nconfig([<span class=\"hljs-string\">'$routeProvider'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">$routeProvider</span>) </span>{\n\n  $routeProvider.when(<span class=\"hljs-string\">'/app/user'</span>,{\n    controller: <span class=\"hljs-string\">'UserController'</span>,\n    templateUrl: <span class=\"hljs-string\">'/templates/user/index.html'</span>\n  });\n}]);\n</code></pre>\n<p>So, here we have our app module - which must match the ngApp directive in <code>layout.ejs</code> - and its dependencies, including Sails&#39; socket.io client, our controllers, directives, filters and services.</p>\n<p>If you open your app up now, you&#39;ll see an error in the console - something like <code>Uncaught ReferenceError: angular is not defined</code>. This is because <code>app.js</code> is loaded but the Bower components are not. Sails has a set of Grunt tasks that are run when you start the server and compile your app into <code>.tmp/public/</code>. These can be found and configured in <code>tasks/</code>, along with the <code>pipeline.js</code> file, which is where the load order of our assets is defined. Open the file up and amend the JavaScript files section to look like this:</p>\n<pre><code class=\"lang-js\">var jsFilesToInject = [\n\n  <span class=\"hljs-regexp\">//</span> <span class=\"hljs-constant\">Load</span> sails.io before everything <span class=\"hljs-keyword\">else</span>\n  <span class=\"hljs-string\">'js/dependencies/sails.io.js'</span>,\n\n  <span class=\"hljs-regexp\">//</span> <span class=\"hljs-constant\">Load</span> <span class=\"hljs-constant\">Angular</span> <span class=\"hljs-keyword\">and</span> other <span class=\"hljs-constant\">Bower</span> components\n  <span class=\"hljs-string\">'bower_components/angular/angular.js'</span>,\n  <span class=\"hljs-string\">'bower_components/angular-route/angular-route.js'</span>,\n  <span class=\"hljs-string\">'bower_components/angularSails/dist/ngsails.io.js'</span>,\n\n  <span class=\"hljs-regexp\">//</span> <span class=\"hljs-constant\">Load</span> <span class=\"hljs-constant\">Angular</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">module</span> <span class=\"hljs-title\">files</span></span>\n  <span class=\"hljs-string\">'js/app.js'</span>,\n  <span class=\"hljs-string\">'js/controllers/controllers.js'</span>,\n  <span class=\"hljs-string\">'js/services/services.js'</span>,\n\n  ...\n]\n</code></pre>\n<h5 id=\"-mmmmmvc\">= MmmmmVC</h5>\n<p>Now our dependencies are loaded correctly but you&#39;ll still receive some Angular-related console errors as some of them don&#39;t exist yet! Let&#39;s create a <code>controllers/controllers.js</code> file:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-pi\">'use strict'</span>;\n\n<span class=\"hljs-keyword\">var</span> appControllers = angular.module(<span class=\"hljs-string\">'app.controllers'</span>, []);\n</code></pre>\n<p>And <code>services/services.js</code>:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-pi\">'use strict'</span>;\n\n<span class=\"hljs-keyword\">var</span> appServices = angular.module(<span class=\"hljs-string\">'app.services'</span>, []);\n</code></pre>\n<p>These files allow us to define our individual controllers/services on global modules. This means we only have to declare single modules for controllers/services when initiating the app.</p>\n<p>So now we&#39;ll create a couple of controllers - an <code>AppController</code> to handle app-wide logic and a more specific <code>UserController</code> to enable data transfer between the user view and API (or model).</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-pi\">'use strict'</span>;\n\n<span class=\"hljs-comment\">// AppController</span>\n\nappControllers.controller(<span class=\"hljs-string\">'AppController'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">$scope, UserFactory</span>) </span>{\n\n  $scope.socket = io.connect();\n\n  $scope.socket.on(<span class=\"hljs-string\">\"connect\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"socket connected\"</span>);\n  });\n\n});\n</code></pre>\n<p>Here, the <code>AppController</code> is simply attaching the socket to the local <code>$scope</code> object and listening for the <code>connect</code> event. In a proper app this controller might also handle sessions and nav/route management - anything that will occur on the wider app view rather than specific views.</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-pi\">'use strict'</span>;\n\n<span class=\"hljs-comment\">// UserController</span>\n\nappControllers.controller(<span class=\"hljs-string\">'UserController'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">$scope, UserFactory</span>) </span>{\n\n  $scope.users = UserFactory.users;\n\n  $scope.getUsers = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    UserFactory.getUsers().\n      then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        $scope.users = UserFactory.users;\n        });\n    };\n\n    <span class=\"hljs-comment\">// On View Loaded</span>\n    $scope.$on(<span class=\"hljs-string\">'$viewContentLoaded'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n      $scope.getUsers();\n    });\n});\n</code></pre>\n<p>The <code>UserController</code> listens for the <code>$viewContentLoaded</code> event on the users view and then fires the <code>getUsers()</code> method, which has been attached to the <code>$scope</code>. You&#39;ll also notice the <code>UserFactory</code> dependency has been injected into the controller - this is the service used to request data from the API via web sockets.</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-pi\">'use strict'</span>;\n\n<span class=\"hljs-comment\">// UserFactory</span>\n\nappServices.factory(<span class=\"hljs-string\">'UserFactory'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">UserFactory</span> (<span class=\"hljs-params\">$sailsSocket</span>) </span>{\n\n  UserFactory.users = [];\n\n  <span class=\"hljs-comment\">// index - /user</span>\n  UserFactory.getUsers = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> $sailsSocket.get(<span class=\"hljs-string\">'/user'</span>).\n      success(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, status, headers, config</span>) </span>{\n        UserFactory.users = data.users;\n      }).\n      error(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data, status, headers, config</span>) </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"error:\"</span>, data);\n      });\n    };\n\n  <span class=\"hljs-keyword\">return</span> UserFactory;\n\n});\n</code></pre>\n<p>The service uses the Angular-Sails binding by injecting <code>$sailsSocket</code> as a dependency. We can then call the <code>get</code> method to hit our API&#39;s endpoints. This method will return a promise that&#39;ll either resolve to <code>success</code> or <code>error</code>. These callbacks are in turn handled by <code>then</code> or <code>fail</code> on the controller. If the promise resolves successfully the <code>$scope.users</code> array will be updated with data from the API.</p>\n<p>That&#39;s pretty much all the logic we&#39;ll need on the client so let&#39;s move to the server and open up <code>api/controllers/UserController.js</code>. This file (along with <code>api/models/user.js</code>) is automatically generated when you run <code>$ sails generate api User</code>. Add the following method to handle the client&#39;s data request:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>.exports = {\n  index: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res, next</span>) </span>{\n\n    <span class=\"hljs-comment\">// get all users</span>\n    User.find(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">usersFound</span> (<span class=\"hljs-params\">err, users</span>) </span>{\n\n      <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">return</span> next(err);\n\n      <span class=\"hljs-keyword\">return</span> res.send(<span class=\"hljs-number\">200</span>, {\n        users: users\n      });\n    });\n  }\n}\n</code></pre>\n<p>Finally, we need to display this data on the page. We&#39;ll use the <code>templates/users.html</code> template for this:</p>\n<pre><code class=\"lang-html\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">li</span> <span class=\"hljs-attribute\">ng-repeat</span>=<span class=\"hljs-value\">\"user in users\"</span>&gt;</span>\n    </span><span class=\"hljs-expression\">{{ <span class=\"hljs-string\">\"{{ user.id \"</span>}}</span><span class=\"xml\">}} - </span><span class=\"hljs-expression\">{{ <span class=\"hljs-string\">\"{{ user.username \"</span>}}</span><span class=\"xml\">}}\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ul</span>&gt;</span></span>\n</code></pre>\n<p>If you navigate to <a href=\"http://localhost:1337/#/app/user\">http://localhost:1337/#/app/user</a> you should see a list of users. Nice work! :boat:</p>\n<h5 id=\"resources\">Resources</h5>\n<ul>\n<li><a href=\"http://balderdashy.github.io/angularSails/#/api/ngsails.$sailsSocket\">angularSails</a></li>\n<li><a href=\"http://toddmotto.com/rethinking-angular-js-controllers/\">Angular Controllers</a></li>\n<li><a href=\"https://docs.angularjs.org/guide/services\">Angular Services</a></li>\n<li><a href=\"http://www.sitepoint.com/practical-guide-angularjs-directives/\">Angular Directives</a></li>\n<li><a href=\"http://toddmotto.com/everything-about-custom-filters-in-angular-js/\">Angular Filters</a></li>\n</ul>\n<p>Any questions leave a comment! &darr;</p>\n"},"divshot":{"title":"Divshot (to the face)","detail":"Deploying a static website during the zombie apocalypse","read":3,"tags":"divshot","comments":true,"slug":"divshot","status":"published","date":"04-09-2014","body":"<p>It&#39;s coming. No doubt about it. I can hear the sound of inevitability from here. But the real question is: could you still deploy a static website during the Zombie Apocalypse?</p>\n<p>I recently put my first <a href=\"http://www.divshot.com/\">Divshot</a> site live. Shortly after that, in a completely unrelated experience - or so I though at the time - I watched <a href=\"http://www.worldwarzmovie.com/\">World War Z</a>. In the days that followed I began to wonder whether a site could be deployed during the zombie apocalypse and how long it might last.</p>\n<h5 id=\"a-divshot-in-the-dark\">A Divshot in the dark</h5>\n<p>If you haven&#39;t come across Divshot before it is a <a href=\"http://www.staticapps.org/\">static website</a> hosting platform and has some awesome features like CLI deployment, multiple hosting environments and <a href=\"https://twitter.com/divshot/status/495491565368795138\">great support</a>. Turns out these are all really useful in a zombie-ridden world as well as the real one...</p>\n<h5 id=\"command-line-in-your-face-deployment\">Command Line In-your-face deployment</h5>\n<p>Deploying with Divshot is fast. Super-fast. You&#39;re going to need this in your locker when faced with an army of undead to warn the world of impending doom. Assumming you&#39;ve got your static zombie-proof site already setup, you can deploy with <code>divshot push</code> straight from the command line. <a href=\"http://www.divshot.com/blog/product-updates/faster-deploys/\">This post</a> about faster deployment took <strong>3.7 seconds</strong> to deploy.</p>\n<h5 id=\"safe-environments\">Safe environments</h5>\n<p>It&#39;s all well and good having a rapid deployment strategy but how will you know that the apocalypse has started? Sure, if it all kicks-off at the end of your street you&#39;ll know it&#39;s time to push your zombie warning live but if it starts in downtown New York you&#39;re going to need a nudge. I&#39;ve created a <a href=\"https://ifttt.com/recipes/201061-zombie-alert\">recipe</a> on <a href=\"http://ift.tt/\">IFTTT</a> that checks the New York Times for articles containing the word &quot;zombie&quot; and sends a notification to my Android phone. Now, when I see this alert, I&#39;ll know it&#39;s time.</p>\n<p>I can also leverage the immense popularity of my current Divshot app to ensure maximum reach of my zombie warning by storing it on the <code>staging</code> environment and executing <code>divshot promote staging production</code> when the alert comes through.</p>\n<h5 id=\"survival-of-the-biggest-network-\">Survival of the biggest (network)</h5>\n<p>So, you&#39;re one step ahead of the zombies and you&#39;ve deployed your static website warning the world about the apocalypse but how long will it survive? According to the <a href=\"http://www.divshot.com/features\">Divshot features page</a> they have <em>&quot;a global network of edge servers spanning over 90 countries&quot;</em>. According to <a href=\"http://geography.about.com/od/lists/a/averagecountry.htm\">this trustworthy source</a>, the average population of a country is 34,020,600.</p>\n<p><code>34,020,600 * 90 = 3,061,854,000</code></p>\n<p>Based on <a href=\"http://www.empireonline.com/features/world-war-z-science\">this scientific model</a> it would take just over a week for those 90 countries to be conquered. I imagine the Divshot servers wouldn&#39;t last too much longer.</p>\n<p>And there you have it: a bulletproof plan for warning the world about the Zombie Apocalypse. If you&#39;ve got any other ideas on how our web apps can survive the zombie apocalypse leave a comment!</p>\n"},"openshift":{"title":"OpenShift","detail":"Node.js hosting on OpenShift","read":15,"tags":"node hosting","comments":true,"slug":"openshift","status":"published","date":"01-06-2015","body":"<p>You&#39;ve just finished building a killer Node-based API but need a host who doesn&#39;t rip you off - who can you turn to?</p>\n<h5 id=\"free\">Free</h5>\n<p>With the <a href=\"https://blog.nodejitsu.com/nodejitsu-joins-godaddy/\">demise of Nodejitsu</a>, it&#39;s not easy finding free Node.js hosting these days. But OpenShift has a <a href=\"https://www.openshift.com/web-hosting/node-js\">really good free plan</a> with capacity for 3 applications. You&#39;re tied to an <code>rhcloud.com</code> subdomain but if you&#39;re just hosting an API or service who cares?</p>\n<h5 id=\"bit-of-a-git\">Bit of a git</h5>\n<p>It&#39;s free, happy days! But I did find the setup slightly painful. I wanted a setup similar to <a href=\"https://divshot.com/\">Divshot</a>: <code>npm install crazy-shit</code>, <code>init bruv</code> and <code>deploy to-the-world</code>. No such luck but it&#39;s not too bad once you know how...</p>\n<p>Sign-up for an account, create a new app using the <code>nodejs-0.10</code> cartridge and away you go. OpenShift basically hosts a Git repo on its server holding all your project&#39;s code - when you create a new Node.js app they initialise it with a sample Express.js app. Once you&#39;ve completed the app creation process, OpenShift will prompt you to clone this repo. You can do this, edit the code and <code>git add/commit/push</code> and this will deploy changes to your site. Kinda cool. But, most likely, you&#39;ve already got a repo (or will set one up) on GitHub/Bitbucket to store your code. I guess it&#39;ll be down to personal preference but I felt more comfortable storing my primary codebase on GitHub and then just pushing to OpenShift when I was ready to deploy. If you&#39;re with me on that one follow the below steps to merge the two repos otherwise don&#39;t pass Go.</p>\n<p>First create a new remote on your existing repo to the OpenShift repo:</p>\n<pre><code class=\"lang-bash\">$ git remote <span class=\"hljs-keyword\">add </span>openshift -f &lt;openshift-git-repo-url&gt;\n</code></pre>\n<p>Then run:</p>\n<pre><code class=\"lang-bash\">$ git <span class=\"hljs-operator\"><span class=\"hljs-keyword\">merge</span> openshift/<span class=\"hljs-keyword\">master</span> -s recursive -X ours</span>\n</code></pre>\n<p>All the files from your OpenShift repo will merge into your local repo - fix any conflicts and then:</p>\n<pre><code class=\"lang-bash\">$ git <span class=\"hljs-keyword\">push </span>openshift HEAD\n</code></pre>\n<p>Now, you&#39;ll be able to make changes to your code and <code>git push</code> to your GitHub repo as normal. Anytime you want to push to OpenShift (thus deploying your site) run <code>git push openshift</code>. Simple. It&#39;s just a deploy process using Git - once you&#39;re cool with that OpenShift feels like a breeze.</p>\n<h5 id=\"host-port\">Host/Port</h5>\n<p>When you point your server to a host/port you&#39;ll need to use OpenShift&#39;s environment variables with a local fallback. Here&#39;s a quick sample Express server:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>),\n    app = express();\n\n<span class=\"hljs-keyword\">var</span> server_ip_address = process.env.OPENSHIFT_NODEJS_IP || <span class=\"hljs-string\">'127.0.0.1'</span>;\n<span class=\"hljs-keyword\">var</span> server_port = process.env.OPENSHIFT_NODEJS_PORT || <span class=\"hljs-number\">3000</span>;\n\napp.get(<span class=\"hljs-string\">'/'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res</span>) </span>{\n    res.send(<span class=\"hljs-string\">'Hello World!'</span>);\n});\n\n<span class=\"hljs-keyword\">var</span> server = app.listen(server_port, server_ip_address, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> host = server.address().address,\n        port = server.address().port;\n\n    <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"Listening on http://\"</span> + host + <span class=\"hljs-string\">\":\"</span> + port );\n});\n</code></pre>\n<h5 id=\"cli\">CLI</h5>\n<p>OpenShift has a tool called <code>rhc</code> that&#39;s useful for managing your apps on the command-line. Install it and setup with:</p>\n<pre><code class=\"lang-bash\"><span class=\"hljs-variable\">$ </span>gem install rhc\n<span class=\"hljs-variable\">$ </span>rhc setup\n</code></pre>\n<p>You can then get a list of your apps:</p>\n<pre><code class=\"lang-bash\"><span class=\"hljs-variable\">$ </span>rhc apps\n</code></pre>\n<h5 id=\"env-vars\">Env vars</h5>\n<p>Another useful command is setting environment variables:</p>\n<pre><code class=\"lang-bash\">$ rhc env set VARIABLE1=VALUE1 -<span class=\"hljs-tag\">a</span> appname\n$ rhc env list -<span class=\"hljs-tag\">a</span> appname\n</code></pre>\n<h5 id=\"server-logs\">Server logs</h5>\n<p>OpenShift provides a shortcut for SSHing onto your server - find it on your application&#39;s dashboard under &quot;Remote Access&quot;. Once you&#39;re on, you can find the server logs under: <code>app-root/logs/</code></p>\n"},"twilio":{"title":"Twilio","detail":"Hunting treasure with Twilio","read":10,"tags":"node twilio mobile","comments":true,"slug":"twilio","status":"draft","body":"<p>Bit of an intro</p>\n<h2 id=\"x-marks-the-spot\">X marks the spot</h2>\n<ul>\n<li>sms/response example -&gt; <a href=\"https://github.com/lukehedger/treasure-hunt-twilio\">https://github.com/lukehedger/treasure-hunt-twilio</a></li>\n</ul>\n"}}}